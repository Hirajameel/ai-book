"use strict";(globalThis.webpackChunkfrontend_docu=globalThis.webpackChunkfrontend_docu||[]).push([[6383],{8453(e,n,t){t.d(n,{R:()=>i,x:()=>r});var s=t(6540);const a={},o=s.createContext(a);function i(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function r(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),s.createElement(o.Provider,{value:n},e.children)}},9226(e,n,t){t.r(n),t.d(n,{assets:()=>l,contentTitle:()=>r,default:()=>_,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"module-1-robotic-nervous-system/additional-examples","title":"Additional Code Examples for ROS 2 Humanoid Robot","description":"This document provides additional code examples that complement the chapters in Module 1.","source":"@site/docs/module-1-robotic-nervous-system/additional-examples.md","sourceDirName":"module-1-robotic-nervous-system","slug":"/module-1-robotic-nervous-system/additional-examples","permalink":"/ai-book/docs/module-1-robotic-nervous-system/additional-examples","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-1-robotic-nervous-system/additional-examples.md","tags":[],"version":"current","frontMatter":{}}');var a=t(4848),o=t(8453);const i={},r="Additional Code Examples for ROS 2 Humanoid Robot",l={},c=[{value:"1. Complete Humanoid Robot Controller Node",id:"1-complete-humanoid-robot-controller-node",level:2},{value:"2. ROS 2 Service for Robot State Management",id:"2-ros-2-service-for-robot-state-management",level:2},{value:"3. Sensor Fusion Node for Humanoid Robot",id:"3-sensor-fusion-node-for-humanoid-robot",level:2},{value:"4. URDF Validation Script",id:"4-urdf-validation-script",level:2}];function f(e){const n={code:"code",h1:"h1",h2:"h2",header:"header",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(n.header,{children:(0,a.jsx)(n.h1,{id:"additional-code-examples-for-ros-2-humanoid-robot",children:"Additional Code Examples for ROS 2 Humanoid Robot"})}),"\n",(0,a.jsx)(n.p,{children:"This document provides additional code examples that complement the chapters in Module 1."}),"\n",(0,a.jsx)(n.h2,{id:"1-complete-humanoid-robot-controller-node",children:"1. Complete Humanoid Robot Controller Node"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Float64MultiArray\nfrom sensor_msgs.msg import JointState, Imu\nfrom geometry_msgs.msg import Twist\nimport numpy as np\nimport math\n\nclass HumanoidRobotController(Node):\n    \"\"\"\n    Complete controller for a humanoid robot that integrates\n    sensor processing, AI decision making, and motor control.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('humanoid_robot_controller')\n\n        # Robot configuration\n        self.joint_names = [\n            'left_hip_joint', 'left_knee_joint', 'left_ankle_joint',\n            'right_hip_joint', 'right_knee_joint', 'right_ankle_joint',\n            'left_shoulder_joint', 'left_elbow_joint',\n            'right_shoulder_joint', 'right_elbow_joint'\n        ]\n\n        # Current and target joint positions\n        self.current_positions = {name: 0.0 for name in self.joint_names}\n        self.target_positions = {name: 0.0 for name in self.joint_names}\n        self.desired_velocities = {name: 0.0 for name in self.joint_names}\n\n        # Robot state\n        self.robot_state = 'idle'  # idle, walking, balancing, interacting\n        self.balance_active = False\n        self.walk_phase = 0.0\n\n        # Publishers\n        self.joint_cmd_publisher = self.create_publisher(\n            JointState, 'joint_commands', 10)\n        self.status_publisher = self.create_publisher(\n            String, 'robot_status', 10)\n\n        # Subscribers\n        self.joint_state_subscriber = self.create_subscription(\n            JointState, 'joint_states', self.joint_state_callback, 10)\n        self.imu_subscriber = self.create_subscription(\n            Imu, 'imu_data', self.imu_callback, 10)\n        self.cmd_vel_subscriber = self.create_subscription(\n            Twist, 'cmd_vel', self.cmd_vel_callback, 10)\n\n        # Timer for control loop\n        self.control_timer = self.create_timer(0.02, self.control_loop)  # 50 Hz\n\n        # Balance control parameters\n        self.balance_kp = 10.0  # Proportional gain\n        self.balance_kd = 1.0   # Derivative gain\n\n        self.get_logger().info('Humanoid Robot Controller initialized')\n\n    def joint_state_callback(self, msg):\n        \"\"\"Update current joint positions from joint state messages\"\"\"\n        for i, name in enumerate(msg.name):\n            if name in self.current_positions:\n                self.current_positions[name] = msg.position[i]\n\n    def imu_callback(self, msg):\n        \"\"\"Process IMU data for balance control\"\"\"\n        # Extract orientation (simplified - in real system use quaternions properly)\n        roll = math.atan2(2.0 * (msg.orientation.w * msg.orientation.x +\n                                msg.orientation.y * msg.orientation.z),\n                         1.0 - 2.0 * (msg.orientation.x * msg.orientation.x +\n                                     msg.orientation.y * msg.orientation.y))\n\n        pitch = math.asin(2.0 * (msg.orientation.w * msg.orientation.y -\n                                msg.orientation.z * msg.orientation.x))\n\n        # Update balance control based on orientation\n        if self.balance_active:\n            self.adjust_balance(roll, pitch)\n\n    def cmd_vel_callback(self, msg):\n        \"\"\"Handle velocity commands for locomotion\"\"\"\n        linear_x = msg.linear.x\n        angular_z = msg.angular.z\n\n        if abs(linear_x) > 0.01 or abs(angular_z) > 0.01:\n            self.robot_state = 'walking'\n        else:\n            self.robot_state = 'balancing'\n\n    def adjust_balance(self, roll_error, pitch_error):\n        \"\"\"Apply balance correction to ankle joints\"\"\"\n        # Simple PD controller for balance\n        roll_correction = self.balance_kp * roll_error\n        pitch_correction = self.balance_kp * pitch_error\n\n        # Apply corrections to ankle joints\n        self.target_positions['left_ankle_joint'] += roll_correction\n        self.target_positions['right_ankle_joint'] += roll_correction\n        self.target_positions['left_ankle_joint'] += pitch_correction * 0.5\n        self.target_positions['right_ankle_joint'] -= pitch_correction * 0.5\n\n        # Limit corrections to safe ranges\n        for joint in ['left_ankle_joint', 'right_ankle_joint']:\n            self.target_positions[joint] = max(-0.3, min(0.3, self.target_positions[joint]))\n\n    def control_loop(self):\n        \"\"\"Main control loop that updates robot behavior\"\"\"\n        # Update target positions based on current state\n        self.update_target_positions()\n\n        # Create and publish joint command\n        cmd_msg = JointState()\n        cmd_msg.header.stamp = self.get_clock().now().to_msg()\n        cmd_msg.name = self.joint_names\n        cmd_msg.position = [self.target_positions[name] for name in self.joint_names]\n        cmd_msg.velocity = [self.desired_velocities[name] for name in self.joint_names]\n\n        self.joint_cmd_publisher.publish(cmd_msg)\n\n        # Publish status\n        status_msg = String()\n        status_msg.data = f\"State: {self.robot_state}, Balance: {self.balance_active}\"\n        self.status_publisher.publish(status_msg)\n\n    def update_target_positions(self):\n        \"\"\"Update target joint positions based on robot state\"\"\"\n        if self.robot_state == 'walking':\n            self.walk_pattern()\n        elif self.robot_state == 'balancing':\n            self.balance_pattern()\n        elif self.robot_state == 'idle':\n            self.idle_pattern()\n        else:\n            self.default_pattern()\n\n    def walk_pattern(self):\n        \"\"\"Generate walking gait pattern\"\"\"\n        self.walk_phase += 0.1\n\n        # Simple walking gait - alternate leg movement\n        left_leg_phase = self.walk_phase\n        right_leg_phase = self.walk_phase + math.pi  # Opposite phase\n\n        # Hip movement (raising and lowering legs)\n        self.target_positions['left_hip_joint'] = 0.1 * math.sin(left_leg_phase)\n        self.target_positions['right_hip_joint'] = 0.1 * math.sin(right_leg_phase)\n\n        # Knee movement (bending to clear ground)\n        self.target_positions['left_knee_joint'] = 0.5 + 0.3 * math.sin(left_leg_phase * 2)\n        self.target_positions['right_knee_joint'] = 0.5 + 0.3 * math.sin(right_leg_phase * 2)\n\n        # Ankle movement (maintaining foot orientation)\n        self.target_positions['left_ankle_joint'] = -0.1 * math.sin(left_leg_phase)\n        self.target_positions['right_ankle_joint'] = -0.1 * math.sin(right_leg_phase)\n\n    def balance_pattern(self):\n        \"\"\"Return to neutral balance position\"\"\"\n        for name in self.joint_names:\n            # Smooth transition to neutral position\n            current = self.current_positions[name]\n            target = 0.0  # Neutral position\n            # Apply a smooth transition\n            self.target_positions[name] = current * 0.95 + target * 0.05\n\n    def idle_pattern(self):\n        \"\"\"Standing position\"\"\"\n        self.target_positions['left_hip_joint'] = 0.0\n        self.target_positions['left_knee_joint'] = 0.0\n        self.target_positions['left_ankle_joint'] = 0.0\n        self.target_positions['right_hip_joint'] = 0.0\n        self.target_positions['right_knee_joint'] = 0.0\n        self.target_positions['right_ankle_joint'] = 0.0\n\n    def default_pattern(self):\n        \"\"\"Default safe position\"\"\"\n        self.idle_pattern()\n\ndef main(args=None):\n    rclpy.init(args=args)\n    controller = HumanoidRobotController()\n\n    try:\n        rclpy.spin(controller)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        controller.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"2-ros-2-service-for-robot-state-management",children:"2. ROS 2 Service for Robot State Management"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom rclpy.action import ActionServer, GoalResponse, CancelResponse\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom your_interfaces.srv import SetRobotState  # Custom service\nfrom your_interfaces.action import WalkToPose  # Custom action\nimport time\n\nclass RobotStateManager(Node):\n    \"\"\"\n    Service and action server for managing robot states\n    and executing complex behaviors.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('robot_state_manager')\n\n        # Service server for immediate state changes\n        self.state_service = self.create_service(\n            SetRobotState,\n            'set_robot_state',\n            self.set_robot_state_callback)\n\n        # Action server for complex behaviors\n        self.walk_action_server = ActionServer(\n            self,\n            WalkToPose,\n            'walk_to_pose',\n            execute_callback=self.execute_walk_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback,\n            callback_group=ReentrantCallbackGroup())\n\n        self.current_state = 'idle'\n        self.is_moving = False\n\n        self.get_logger().info('Robot State Manager initialized')\n\n    def set_robot_state_callback(self, request, response):\n        \"\"\"Handle immediate state change requests\"\"\"\n        requested_state = request.state_command\n\n        if requested_state in ['stand', 'sit', 'walk', 'stop', 'balance', 'idle']:\n            old_state = self.current_state\n            self.current_state = requested_state\n\n            response.success = True\n            response.message = f'State changed from {old_state} to {requested_state}'\n            response.error_code = 0\n\n            self.get_logger().info(f'State changed: {old_state} -> {requested_state}')\n        else:\n            response.success = False\n            response.message = f'Invalid state command: {requested_state}'\n            response.error_code = 1\n\n        return response\n\n    def goal_callback(self, goal_request):\n        \"\"\"Accept or reject walk goals\"\"\"\n        self.get_logger().info(f'Received walk goal: {goal_request.target_pose}')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        \"\"\"Accept or reject goal cancellation\"\"\"\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n\n    async def execute_walk_callback(self, goal_handle):\n        \"\"\"Execute the walk behavior\"\"\"\n        self.get_logger().info('Starting walk execution')\n\n        feedback_msg = WalkToPose.Feedback()\n        result = WalkToPose.Result()\n\n        target_pose = goal_handle.request.target_pose\n        tolerance = goal_handle.request.tolerance\n\n        # Simulate walking behavior\n        steps = 0\n        max_steps = 100  # Maximum steps to prevent infinite loops\n\n        while steps < max_steps:\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                result.success = False\n                result.message = 'Goal canceled'\n                return result\n\n            # Simulate progress toward target\n            # In a real system, this would use actual robot position feedback\n            remaining_distance = max(0.0, 1.0 - (steps / max_steps))\n\n            feedback_msg.current_pose = self.get_current_pose()  # Would need implementation\n            feedback_msg.remaining_distance = remaining_distance\n            feedback_msg.status = f'Walking... {remaining_distance:.2f}m remaining'\n\n            goal_handle.publish_feedback(feedback_msg)\n\n            # Check if we've reached the target\n            if remaining_distance < tolerance:\n                break\n\n            # Simulate step delay\n            time.sleep(0.1)\n            steps += 1\n\n        if steps < max_steps:\n            goal_handle.succeed()\n            result.success = True\n            result.message = f'Reached target pose in {steps} steps'\n        else:\n            goal_handle.abort()\n            result.success = False\n            result.message = f'Failed to reach target after {max_steps} steps'\n\n        self.get_logger().info(result.message)\n        return result\n\n    def get_current_pose(self):\n        \"\"\"Get current robot pose (placeholder)\"\"\"\n        # This would interface with localization system in real implementation\n        from geometry_msgs.msg import Pose\n        pose = Pose()\n        pose.position.x = 0.0\n        pose.position.y = 0.0\n        pose.position.z = 0.0\n        pose.orientation.w = 1.0\n        return pose\n\ndef main(args=None):\n    rclpy.init(args=args)\n    state_manager = RobotStateManager()\n\n    try:\n        rclpy.spin(state_manager)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        state_manager.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"3-sensor-fusion-node-for-humanoid-robot",children:"3. Sensor Fusion Node for Humanoid Robot"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String, Float32, Bool\nfrom sensor_msgs.msg import JointState, Imu, LaserScan\nimport statistics\nimport numpy as np\nfrom collections import deque\n\nclass SensorFusionNode(Node):\n    \"\"\"\n    Fuses data from multiple sensors to create a comprehensive\n    understanding of the robot's state and environment.\n    \"\"\"\n\n    def __init__(self):\n        super().__init__('sensor_fusion_node')\n\n        # Sensor data buffers\n        self.imu_buffer = deque(maxlen=10)\n        self.lidar_buffer = deque(maxlen=20)\n        self.joint_buffer = deque(maxlen=5)\n\n        # Processed data\n        self.robot_pose = {'x': 0.0, 'y': 0.0, 'theta': 0.0}\n        self.balance_state = 'stable'\n        self.obstacle_distance = float('inf')\n        self.safety_status = 'safe'\n\n        # Publishers\n        self.fused_data_publisher = self.create_publisher(\n            String, 'fused_sensor_data', 10)\n        self.safety_publisher = self.create_publisher(\n            Bool, 'safety_status', 10)\n\n        # Subscribers\n        self.imu_subscriber = self.create_subscription(\n            Imu, 'imu_data', self.imu_callback, 10)\n        self.lidar_subscriber = self.create_subscription(\n            LaserScan, 'scan', self.lidar_callback, 10)\n        self.joint_subscriber = self.create_subscription(\n            JointState, 'joint_states', self.joint_callback, 10)\n\n        # Timer for fusion processing\n        self.fusion_timer = self.create_timer(0.1, self.process_fusion)\n\n        self.get_logger().info('Sensor Fusion Node initialized')\n\n    def imu_callback(self, msg):\n        \"\"\"Process IMU data\"\"\"\n        # Extract orientation (simplified)\n        orientation = msg.orientation\n        # Convert quaternion to roll/pitch/yaw would be done here\n        # For simplicity, we'll just store the raw data\n        self.imu_buffer.append({\n            'orientation': (orientation.x, orientation.y, orientation.z, orientation.w),\n            'angular_velocity': (msg.angular_velocity.x, msg.angular_velocity.y, msg.angular_velocity.z),\n            'linear_acceleration': (msg.linear_acceleration.x, msg.linear_acceleration.y, msg.linear_acceleration.z)\n        })\n\n        # Assess balance state from IMU data\n        self.assess_balance_from_imu()\n\n    def lidar_callback(self, msg):\n        \"\"\"Process LIDAR data\"\"\"\n        # Store distance measurements\n        self.lidar_buffer.append({\n            'ranges': list(msg.ranges),\n            'min_angle': msg.angle_min,\n            'max_angle': msg.angle_max,\n            'angle_increment': msg.angle_increment\n        })\n\n        # Find closest obstacle\n        valid_ranges = [r for r in msg.ranges if 0.1 < r < 10.0]  # Filter invalid ranges\n        if valid_ranges:\n            self.obstacle_distance = min(valid_ranges)\n        else:\n            self.obstacle_distance = float('inf')\n\n    def joint_callback(self, msg):\n        \"\"\"Process joint state data\"\"\"\n        self.joint_buffer.append({\n            'position': dict(zip(msg.name, msg.position)),\n            'velocity': dict(zip(msg.name, msg.velocity)),\n            'effort': dict(zip(msg.name, msg.effort))\n        })\n\n    def assess_balance_from_imu(self):\n        \"\"\"Determine balance state from IMU data\"\"\"\n        if not self.imu_buffer:\n            return\n\n        # Get the most recent IMU data\n        recent_imu = self.imu_buffer[-1]\n        linear_acc = recent_imu['linear_acceleration']\n\n        # Calculate tilt angles (simplified)\n        tilt_x = np.arctan2(linear_acc[0], linear_acc[2])\n        tilt_y = np.arctan2(linear_acc[1], linear_acc[2])\n\n        # Determine balance state\n        max_tilt = 0.3  # 0.3 radians ~ 17 degrees\n        if abs(tilt_x) > max_tilt or abs(tilt_y) > max_tilt:\n            self.balance_state = 'unstable'\n        else:\n            self.balance_state = 'stable'\n\n    def process_fusion(self):\n        \"\"\"Process and fuse sensor data\"\"\"\n        # Create fused data message\n        fused_data = {\n            'balance_state': self.balance_state,\n            'obstacle_distance': self.obstacle_distance,\n            'safety_status': self.safety_status,\n            'timestamp': self.get_clock().now().nanoseconds\n        }\n\n        # Determine overall safety status\n        self.safety_status = self.calculate_safety_status()\n\n        # Publish fused data\n        fused_msg = String()\n        fused_msg.data = str(fused_data)\n        self.fused_data_publisher.publish(fused_msg)\n\n        # Publish safety status\n        safety_msg = Bool()\n        safety_msg.data = self.safety_status == 'safe'\n        self.safety_publisher.publish(safety_msg)\n\n        self.get_logger().info(f'Fused data: {fused_data}')\n\n    def calculate_safety_status(self):\n        \"\"\"Calculate overall safety status from all sensors\"\"\"\n        safety_factors = []\n\n        # Balance safety\n        if self.balance_state == 'unstable':\n            safety_factors.append(False)\n        else:\n            safety_factors.append(True)\n\n        # Obstacle safety (if too close)\n        if self.obstacle_distance < 0.5:  # 50cm threshold\n            safety_factors.append(False)\n        else:\n            safety_factors.append(True)\n\n        # Return 'safe' if all factors are safe\n        return 'safe' if all(safety_factors) else 'unsafe'\n\ndef main(args=None):\n    rclpy.init(args=args)\n    fusion_node = SensorFusionNode()\n\n    try:\n        rclpy.spin(fusion_node)\n    except KeyboardInterrupt:\n        pass\n    finally:\n        fusion_node.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,a.jsx)(n.h2,{id:"4-urdf-validation-script",children:"4. URDF Validation Script"}),"\n",(0,a.jsx)(n.pre,{children:(0,a.jsx)(n.code,{className:"language-python",children:"#!/usr/bin/env python3\n\"\"\"\nURDF Validation Script\nThis script validates URDF files and checks for common issues.\n\"\"\"\nimport subprocess\nimport sys\nimport os\nimport xml.etree.ElementTree as ET\n\ndef validate_urdf_file(urdf_path):\n    \"\"\"Validate a URDF file using ROS 2 tools\"\"\"\n    if not os.path.exists(urdf_path):\n        print(f\"Error: URDF file {urdf_path} does not exist\")\n        return False\n\n    try:\n        # Check URDF syntax\n        print(f\"Validating URDF file: {urdf_path}\")\n        result = subprocess.run(['check_urdf', urdf_path],\n                              capture_output=True, text=True)\n        if result.returncode != 0:\n            print(f\"URDF validation failed: {result.stderr}\")\n            return False\n        else:\n            print(\"\u2713 URDF syntax is valid\")\n            return True\n    except FileNotFoundError:\n        print(\"Error: check_urdf command not found. Is ROS 2 installed?\")\n        return False\n    except Exception as e:\n        print(f\"Error validating URDF: {e}\")\n        return False\n\ndef analyze_urdf_structure(urdf_path):\n    \"\"\"Analyze URDF structure for humanoid-specific issues\"\"\"\n    try:\n        tree = ET.parse(urdf_path)\n        root = tree.getroot()\n\n        # Check for robot name\n        robot_name = root.get('name')\n        print(f\"Robot name: {robot_name}\")\n\n        # Count links and joints\n        links = root.findall('.//link')\n        joints = root.findall('.//joint')\n\n        print(f\"Number of links: {len(links)}\")\n        print(f\"Number of joints: {len(joints)}\")\n\n        # Check for essential humanoid components\n        link_names = [link.get('name') for link in links]\n        joint_names = [joint.get('name') for joint in joints]\n\n        essential_parts = {\n            'torso': any('torso' in name.lower() or 'base' in name.lower() for name in link_names),\n            'head': any('head' in name.lower() for name in link_names),\n            'left_leg': any('left' in name.lower() and ('hip' in name.lower() or 'leg' in name.lower()) for name in joint_names),\n            'right_leg': any('right' in name.lower() and ('hip' in name.lower() or 'leg' in name.lower()) for name in joint_names),\n        }\n\n        print(\"\\nEssential humanoid parts check:\")\n        for part, present in essential_parts.items():\n            status = \"\u2713\" if present else \"\u2717\"\n            print(f\"  {status} {part}: {'Present' if present else 'Missing'}\")\n\n        # Check joint types for legs\n        leg_joints = [j for j in joints if 'leg' in j.get('name').lower() or\n                     'hip' in j.get('name').lower() or\n                     'knee' in j.get('name').lower() or\n                     'ankle' in j.get('name').lower()]\n\n        print(f\"\\nLeg joints found: {len(leg_joints)}\")\n        for joint in leg_joints:\n            joint_type = joint.get('type')\n            parent = joint.find('parent').get('link') if joint.find('parent') is not None else 'unknown'\n            child = joint.find('child').get('link') if joint.find('child') is not None else 'unknown'\n            print(f\"  - {joint.get('name')} ({joint_type}): {parent} -> {child}\")\n\n        return True\n\n    except ET.ParseError as e:\n        print(f\"Error parsing URDF XML: {e}\")\n        return False\n    except Exception as e:\n        print(f\"Error analyzing URDF: {e}\")\n        return False\n\ndef generate_kinematic_tree(urdf_path):\n    \"\"\"Generate and display the kinematic tree\"\"\"\n    try:\n        result = subprocess.run(['urdf_to_graphiz', urdf_path],\n                              capture_output=True, text=True)\n        if result.returncode == 0:\n            # Find the generated files\n            base_name = os.path.splitext(urdf_path)[0]\n            dot_file = f\"{base_name}.gv\"\n            if os.path.exists(dot_file):\n                print(f\"\u2713 Kinematic tree generated: {dot_file}\")\n                # Read and display the tree structure\n                with open(dot_file, 'r') as f:\n                    content = f.read()\n                    print(\"\\nKinematic Tree Structure:\")\n                    print(content[:1000] + \"...\" if len(content) > 1000 else content)\n            else:\n                print(\"Could not find generated kinematic tree file\")\n        else:\n            print(f\"Error generating kinematic tree: {result.stderr}\")\n    except Exception as e:\n        print(f\"Error generating kinematic tree: {e}\")\n\ndef main():\n    if len(sys.argv) != 2:\n        print(\"Usage: python3 urdf_validator.py <urdf_file_path>\")\n        sys.exit(1)\n\n    urdf_file = sys.argv[1]\n\n    print(\"=== URDF Validation Tool ===\\n\")\n\n    # Validate syntax\n    if not validate_urdf_file(urdf_file):\n        sys.exit(1)\n\n    print()\n\n    # Analyze structure\n    analyze_urdf_structure(urdf_file)\n\n    print()\n\n    # Generate kinematic tree\n    generate_kinematic_tree(urdf_file)\n\nif __name__ == \"__main__\":\n    main()\n"})}),"\n",(0,a.jsx)(n.p,{children:"These additional code examples provide practical implementations that complement the theoretical content covered in the five chapters. They demonstrate real-world applications of the concepts discussed in the module."})]})}function _(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,a.jsx)(n,{...e,children:(0,a.jsx)(f,{...e})}):f(e)}}}]);