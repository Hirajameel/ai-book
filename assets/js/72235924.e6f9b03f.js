"use strict";(globalThis.webpackChunkfrontend_docu=globalThis.webpackChunkfrontend_docu||[]).push([[573],{8453(n,e,a){a.d(e,{R:()=>r,x:()=>s});var t=a(6540);const o={},i=t.createContext(o);function r(n){const e=t.useContext(i);return t.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(o):n.components||o:r(n.components),t.createElement(i.Provider,{value:e},n.children)}},9467(n,e,a){a.r(e),a.d(e,{assets:()=>l,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>t,toc:()=>c});const t=JSON.parse('{"id":"module-3/nav2-humanoid","title":"Nav2 for Humanoids","description":"Overview","source":"@site/docs/module-3/14-nav2-humanoid.md","sourceDirName":"module-3","slug":"/module-3/nav2-humanoid","permalink":"/ai-book/docs/module-3/nav2-humanoid","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-3/14-nav2-humanoid.md","tags":[],"version":"current","sidebarPosition":14,"frontMatter":{"id":"nav2-humanoid","title":"Nav2 for Humanoids","sidebar_label":"Chapter 14 Nav2 Humanoid"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 13 Isaac ROS VSLAM","permalink":"/ai-book/docs/module-3/isaac-ros-vslam"},"next":{"title":"Chapter 15 Jetson Deployment","permalink":"/ai-book/docs/module-3/jetson-deployment"}}');var o=a(4848),i=a(8453);const r={id:"nav2-humanoid",title:"Nav2 for Humanoids",sidebar_label:"Chapter 14 Nav2 Humanoid"},s="Nav2 for Humanoids",l={},c=[{value:"Overview",id:"overview",level:2},{value:"Key Topics",id:"key-topics",level:2},{value:"Humanoid Navigation Architecture",id:"humanoid-navigation-architecture",level:2},{value:"Nav2 Configuration for Bipedal Movement",id:"nav2-configuration-for-bipedal-movement",level:3},{value:"Costmap Configuration for Humanoids",id:"costmap-configuration-for-humanoids",level:2},{value:"Behavior Trees for Humanoid Navigation",id:"behavior-trees-for-humanoid-navigation",level:2},{value:"Footstep Planning for Bipedal Navigation",id:"footstep-planning-for-bipedal-navigation",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...n.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(e.header,{children:(0,o.jsx)(e.h1,{id:"nav2-for-humanoids",children:"Nav2 for Humanoids"})}),"\n",(0,o.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,o.jsx)(e.p,{children:"This chapter covers Nav2 path planning specifically tuned for bipedal humanoid balance and movement, including costmaps, behavior trees, and bipedal footstep planning. Humanoid navigation requires specialized approaches due to balance constraints and unique locomotion patterns."}),"\n",(0,o.jsx)(e.h2,{id:"key-topics",children:"Key Topics"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsx)(e.li,{children:"Nav2 configuration for bipedal robots"}),"\n",(0,o.jsx)(e.li,{children:"Humanoid-specific costmaps"}),"\n",(0,o.jsx)(e.li,{children:"Behavior trees for navigation"}),"\n",(0,o.jsx)(e.li,{children:"Footstep planning algorithms"}),"\n",(0,o.jsx)(e.li,{children:"Balance-aware path planning"}),"\n"]}),"\n",(0,o.jsx)(e.h2,{id:"humanoid-navigation-architecture",children:"Humanoid Navigation Architecture"}),"\n",(0,o.jsx)(e.p,{children:"The navigation system for bipedal robots requires special considerations for balance and stability:"}),"\n",(0,o.jsxs)(e.ul,{children:["\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Stability-aware path planning"}),": Paths must account for the robot's center of mass"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Footstep planning"}),": Precise placement of feet for stable locomotion"]}),"\n",(0,o.jsxs)(e.li,{children:[(0,o.jsx)(e.strong,{children:"Balance recovery"}),": Behaviors to maintain or regain balance during navigation"]}),"\n"]}),"\n",(0,o.jsx)(e.h3,{id:"nav2-configuration-for-bipedal-movement",children:"Nav2 Configuration for Bipedal Movement"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# Nav2 configuration for humanoid robot navigation\nbt_navigator:\n  ros__parameters:\n    # Behavior tree for humanoid navigation\n    default_bt_xml_filename: "humanoid_navigator_bt.xml"\n    enable_groot_monitoring: True\n    use_sim_time: True\n\ncontroller_server:\n  ros__parameters:\n    # Controller for humanoid movement\n    controller_frequency: 20.0\n    min_x_velocity_threshold: 0.05\n    min_y_velocity_threshold: 0.05\n    min_theta_velocity_threshold: 0.1\n    progress_checker_plugin: "progress_checker"\n    goal_checker_plugin: "goal_checker"\n    controller_plugins: ["FollowPath"]\n\n    # Humanoid-specific controller\n    FollowPath:\n      plugin: "nav2_mppi_controller::MPPIController"\n      time_steps: 25\n      model_dt: 0.05\n      batch_size: 1000\n      vx_std: 0.3\n      vy_std: 0.1\n      wz_std: 0.3\n      vx_max: 0.5\n      vx_min: -0.2\n      vy_max: 0.3\n      wz_max: 0.5\n      # Humanoid-specific constraints\n      balance_constraint_weight: 10.0\n      footstep_constraint_weight: 5.0\n\nlocal_costmap:\n  ros__parameters:\n    update_frequency: 10.0\n    publish_frequency: 5.0\n    global_frame: odom\n    robot_base_frame: base_link\n    use_sim_time: True\n    rolling_window: true\n    width: 6\n    height: 6\n    resolution: 0.05\n    plugins: [\n      "obstacles_layer",\n      "inflation_layer",\n      "footstep_layer",\n      "stability_layer"\n    ]\n\n    obstacles_layer:\n      plugin: "nav2_costmap_2d::ObstacleLayer"\n      enabled: True\n      observation_sources: scan\n      scan:\n        topic: /laser_scan\n        max_obstacle_height: 2.0\n        clearing: True\n        marking: True\n        data_type: "LaserScan"\n\n    inflation_layer:\n      plugin: "nav2_costmap_2d::InflationLayer"\n      enabled: True\n      cost_scaling_factor: 3.0\n      inflation_radius: 0.55\n\n    footstep_layer:\n      plugin: "custom::FootstepLayer"\n      enabled: True\n      # Humanoid-specific parameters\n      foot_separation: 0.3\n      step_height: 0.1\n      max_step_length: 0.4\n\n    stability_layer:\n      plugin: "custom::StabilityLayer"\n      enabled: True\n      # Balance-related parameters\n      com_tracking_weight: 10.0\n      zmp_margin: 0.05\n\nglobal_costmap:\n  ros__parameters:\n    global_frame: map\n    robot_base_frame: base_link\n    update_frequency: 1.0\n    publish_frequency: 1.0\n    resolution: 0.05\n    use_sim_time: True\n    plugins: [\n      "static_layer",\n      "obstacles_layer",\n      "inflation_layer",\n      "stability_layer"\n    ]\n\n    static_layer:\n      plugin: "nav2_costmap_2d::StaticLayer"\n      map_subscribe_transient_local: True\n\n    obstacles_layer:\n      plugin: "nav2_costmap_2d::ObstacleLayer"\n      enabled: True\n      observation_sources: scan\n      scan:\n        topic: /laser_scan\n        max_obstacle_height: 2.0\n        clearing: True\n        marking: True\n        data_type: "LaserScan"\n\n    inflation_layer:\n      plugin: "nav2_costmap_2d::InflationLayer"\n      enabled: True\n      cost_scaling_factor: 3.0\n      inflation_radius: 0.55\n\n    stability_layer:\n      plugin: "custom::StabilityLayer"\n      enabled: True\n      # Balance-related parameters for global planning\n      com_tracking_weight: 5.0\n      zmp_margin: 0.1\n'})}),"\n",(0,o.jsx)(e.h2,{id:"costmap-configuration-for-humanoids",children:"Costmap Configuration for Humanoids"}),"\n",(0,o.jsx)(e.p,{children:"Humanoid robots require specialized costmap layers to account for balance and stability:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-yaml",children:'# Additional humanoid-specific costmap configuration\nlocal_costmap:\n  plugins:\n    - {name: obstacles_layer, type: "nav2_costmap_2d::ObstacleLayer"}\n    - {name: inflation_layer, type: "nav2_costmap_2d::InflationLayer"}\n    - {name: footstep_layer, type: "custom::FootstepLayer"}\n    - {name: stability_layer, type: "custom::StabilityLayer"}\n\nglobal_costmap:\n  plugins:\n    - {name: static_layer, type: "nav2_costmap_2d::StaticLayer"}\n    - {name: obstacles_layer, type: "nav2_costmap_2d::ObstacleLayer"}\n    - {name: inflation_layer, type: "nav2_costmap_2d::InflationLayer"}\n    - {name: stability_layer, type: "custom::StabilityLayer"}\n'})}),"\n",(0,o.jsx)(e.h2,{id:"behavior-trees-for-humanoid-navigation",children:"Behavior Trees for Humanoid Navigation"}),"\n",(0,o.jsx)(e.p,{children:"Behavior trees in Nav2 can be customized for humanoid-specific navigation behaviors:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-xml",children:'\x3c!-- humanoid_navigator_bt.xml --\x3e\n<root main_tree_to_execute="MainTree">\n  <BehaviorTree ID="MainTree">\n    <PipelineSequence name="NavigateWithReplanning">\n      <RateController hz="1.0">\n        <RecoveryNode number_of_retries="6" name="ComputeAndTryController">\n          <PipelineSequence name="ComputeAndExecuteController">\n            <ControllerSelector input_path="goal_path" output_path="selected_path"/>\n            <PathUnwrapper path="{selected_path}"/>\n            <HumanoidController path="{selected_path}"/>\n          </PipelineSequence>\n          <RecoveryNode number_of_retries="2" name="HumanoidSpin">\n            <HumanoidSpin spin_dist="1.57"/>\n          </RecoveryNode>\n        </RecoveryNode>\n      </RateController>\n      <ReactiveSequence name="CheckGoalReached">\n        <GoalReached goal="current_goal" path="goal_path"/>\n        <ComputePathToPose goal="{current_goal}" path="goal_path" planner_id="GridBased"/>\n      </ReactiveSequence>\n    </PipelineSequence>\n  </BehaviorTree>\n</root>\n'})}),"\n",(0,o.jsx)(e.h2,{id:"footstep-planning-for-bipedal-navigation",children:"Footstep Planning for Bipedal Navigation"}),"\n",(0,o.jsx)(e.p,{children:"Footstep planning is critical for humanoid navigation:"}),"\n",(0,o.jsx)(e.pre,{children:(0,o.jsx)(e.code,{className:"language-python",children:'# Python example for humanoid footstep planning\nimport numpy as np\nfrom geometry_msgs.msg import Point\n\nclass HumanoidFootstepPlanner:\n    def __init__(self):\n        self.foot_separation = 0.3  # Distance between feet\n        self.step_height = 0.1      # Height to lift foot during stepping\n        self.max_step_length = 0.4  # Maximum forward step length\n\n    def plan_footsteps(self, path, robot_pose):\n        """\n        Plan stable footsteps for humanoid navigation\n        """\n        footsteps = []\n\n        # Calculate footsteps based on path and robot constraints\n        current_pose = robot_pose\n        for i in range(len(path) - 1):\n            step = self.calculate_next_step(current_pose, path[i+1])\n            if self.is_stable_footstep(step):\n                footsteps.append(step)\n                current_pose = step.end_pose\n\n        return footsteps\n\n    def calculate_next_step(self, current_pose, target_point):\n        """\n        Calculate the next footstep based on current pose and target\n        """\n        # Calculate step direction and distance\n        dx = target_point.x - current_pose.position.x\n        dy = target_point.y - current_pose.position.y\n        distance = np.sqrt(dx**2 + dy**2)\n\n        # Limit step size for stability\n        if distance > self.max_step_length:\n            dx = dx * self.max_step_length / distance\n            dy = dy * self.max_step_length / distance\n\n        # Calculate foot position based on current stance\n        # (left or right foot based on step sequence)\n        foot_position = Point()\n        foot_position.x = current_pose.position.x + dx\n        foot_position.y = current_pose.position.y + dy\n        foot_position.z = current_pose.position.z\n\n        return foot_position\n\n    def is_stable_footstep(self, footstep):\n        """\n        Check if footstep maintains robot stability\n        """\n        # Check if footstep is within support polygon\n        # and maintains center of mass within stable region\n        return True  # Simplified for example\n'})})]})}function d(n={}){const{wrapper:e}={...(0,i.R)(),...n.components};return e?(0,o.jsx)(e,{...n,children:(0,o.jsx)(p,{...n})}):p(n)}}}]);