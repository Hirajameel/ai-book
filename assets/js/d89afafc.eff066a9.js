"use strict";(globalThis.webpackChunkfrontend_docu=globalThis.webpackChunkfrontend_docu||[]).push([[1975],{7055(e,n,i){i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>l,default:()=>u,frontMatter:()=>r,metadata:()=>s,toc:()=>a});const s=JSON.parse('{"id":"module-1-robotic-nervous-system/communication-patterns","title":"Chapter 3 - Deep Dive into Topics, Services, and Actions","description":"Communication Patterns in ROS 2","source":"@site/docs/module-1-robotic-nervous-system/communication-patterns.md","sourceDirName":"module-1-robotic-nervous-system","slug":"/module-1-robotic-nervous-system/communication-patterns","permalink":"/ai-book/docs/module-1-robotic-nervous-system/communication-patterns","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/module-1-robotic-nervous-system/communication-patterns.md","tags":[],"version":"current","frontMatter":{"title":"Chapter 3 - Deep Dive into Topics, Services, and Actions","sidebar_label":"Chapter 3 Deep Dive into Topics, Services, and Actions","id":"communication-patterns"},"sidebar":"tutorialSidebar","previous":{"title":"Chapter 2 Technical Middleware Layers and Humble Configuration","permalink":"/ai-book/docs/module-1-robotic-nervous-system/ros2-architecture-setup"},"next":{"title":"Chapter 4 Implementation of rclpy for AI-Agent Integration","permalink":"/ai-book/docs/module-1-robotic-nervous-system/python-ai-bridge"}}');var t=i(4848),o=i(8453);const r={title:"Chapter 3 - Deep Dive into Topics, Services, and Actions",sidebar_label:"Chapter 3 Deep Dive into Topics, Services, and Actions",id:"communication-patterns"},l="Chapter 3: Deep Dive into Topics, Services, and Actions",c={},a=[{value:"Communication Patterns in ROS 2",id:"communication-patterns-in-ros-2",level:2},{value:"Topics: Publish/Subscribe Pattern",id:"topics-publishsubscribe-pattern",level:2},{value:"Basic Topic Communication",id:"basic-topic-communication",level:3},{value:"Implementing Publisher/Subscriber Pattern",id:"implementing-publishersubscriber-pattern",level:3},{value:"Quality of Service for Topics",id:"quality-of-service-for-topics",level:3},{value:"Services: Request/Response Pattern",id:"services-requestresponse-pattern",level:2},{value:"Service Communication Pattern",id:"service-communication-pattern",level:3},{value:"Implementing Service/Client Pattern",id:"implementing-serviceclient-pattern",level:3},{value:"Actions: Goal-Oriented Communication",id:"actions-goal-oriented-communication",level:2},{value:"Action Communication Pattern",id:"action-communication-pattern",level:3},{value:"Implementing Action Pattern",id:"implementing-action-pattern",level:3},{value:"Humanoid Robot Communication Architecture",id:"humanoid-robot-communication-architecture",level:2},{value:"Performance Considerations",id:"performance-considerations",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const n={admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.header,{children:(0,t.jsx)(n.h1,{id:"chapter-3-deep-dive-into-topics-services-and-actions",children:"Chapter 3: Deep Dive into Topics, Services, and Actions"})}),"\n",(0,t.jsx)(n.h2,{id:"communication-patterns-in-ros-2",children:"Communication Patterns in ROS 2"}),"\n",(0,t.jsx)(n.p,{children:"ROS 2 provides three primary communication patterns for inter-node communication: Topics (publish/subscribe), Services (request/response), and Actions (goal-oriented with feedback). Understanding these patterns is crucial for designing effective humanoid robot systems."}),"\n",(0,t.jsx)(n.h2,{id:"topics-publishsubscribe-pattern",children:"Topics: Publish/Subscribe Pattern"}),"\n",(0,t.jsx)(n.p,{children:"Topics implement an asynchronous, many-to-many communication pattern. Publishers send messages to topics without knowing who subscribes, and subscribers receive messages from topics without knowing who publishes."}),"\n",(0,t.jsx)(n.h3,{id:"basic-topic-communication",children:"Basic Topic Communication"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mermaid",children:"graph LR\n    A[Publisher Node] --\x3e|Publishes Messages| C[Topic: /sensor_data]\n    B[Publisher Node] --\x3e|Publishes Messages| C\n    C --\x3e|Subscribes| D[Subscriber Node]\n    C --\x3e|Subscribes| E[Subscriber Node]\n    C --\x3e|Subscribes| F[Subscriber Node]\n\n    style A fill:#4CAF50\n    style B fill:#4CAF50\n    style C fill:#2196F3\n    style D fill:#FF9800\n    style E fill:#FF9800\n    style F fill:#FF9800\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this diagram:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Green nodes: Publishers (send data)"}),"\n",(0,t.jsx)(n.li,{children:"Blue node: Topic (communication channel)"}),"\n",(0,t.jsx)(n.li,{children:"Orange nodes: Subscribers (receive data)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementing-publishersubscriber-pattern",children:"Implementing Publisher/Subscriber Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\nclass SensorPublisher(Node):\n    def __init__(self):\n        super().__init__('sensor_publisher')\n        self.publisher_ = self.create_publisher(String, 'sensor_data', 10)\n        timer_period = 0.1  # seconds\n        self.timer = self.create_timer(timer_period, self.timer_callback)\n\n    def timer_callback(self):\n        msg = String()\n        msg.data = f'Sensor reading: {self.get_clock().now().nanoseconds}'\n        self.publisher_.publish(msg)\n        self.get_logger().info(f'Publishing: \"{msg.data}\"')\n\nclass MotorSubscriber(Node):\n    def __init__(self):\n        super().__init__('motor_subscriber')\n        self.subscription = self.create_subscription(\n            String,\n            'motor_commands',\n            self.listener_callback,\n            10)\n        self.subscription  # prevent unused variable warning\n\n    def listener_callback(self, msg):\n        self.get_logger().info(f'Received motor command: \"{msg.data}\"')\n\ndef main(args=None):\n    rclpy.init(args=args)\n\n    # Create both nodes\n    sensor_publisher = SensorPublisher()\n    motor_subscriber = MotorSubscriber()\n\n    # Spin both nodes\n    executor = rclpy.executors.MultiThreadedExecutor()\n    executor.add_node(sensor_publisher)\n    executor.add_node(motor_subscriber)\n\n    try:\n        executor.spin()\n    finally:\n        sensor_publisher.destroy_node()\n        motor_subscriber.destroy_node()\n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n"})}),"\n",(0,t.jsx)(n.h3,{id:"quality-of-service-for-topics",children:"Quality of Service for Topics"}),"\n",(0,t.jsx)(n.p,{children:"For humanoid robot applications, QoS settings are critical:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, ReliabilityPolicy, DurabilityPolicy, HistoryPolicy\n\n# For sensor data (high frequency, may lose some messages)\nsensor_qos = QoSProfile(\n    reliability=ReliabilityPolicy.BEST_EFFORT,\n    durability=DurabilityPolicy.VOLATILE,\n    history=HistoryPolicy.KEEP_LAST,\n    depth=5\n)\n\n# For critical control data (must not lose messages)\ncontrol_qos = QoSProfile(\n    reliability=ReliabilityPolicy.RELIABLE,\n    durability=DurabilityPolicy.VOLATILE,\n    history=HistoryPolicy.KEEP_LAST,\n    depth=10\n)\n"})}),"\n",(0,t.jsx)(n.h2,{id:"services-requestresponse-pattern",children:"Services: Request/Response Pattern"}),"\n",(0,t.jsx)(n.p,{children:"Services provide synchronous, one-to-one communication where a client sends a request and waits for a response from a server."}),"\n",(0,t.jsx)(n.h3,{id:"service-communication-pattern",children:"Service Communication Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mermaid",children:"graph LR\n    A[Service Client] --\x3e|Request| C[Service Server]\n    C --\x3e|Response| A\n\n    style A fill:#E91E63\n    style C fill:#9C27B0\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this diagram:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Pink node: Service Client (sends request, waits for response)"}),"\n",(0,t.jsx)(n.li,{children:"Purple node: Service Server (receives request, sends response)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementing-serviceclient-pattern",children:"Implementing Service/Client Pattern"}),"\n",(0,t.jsxs)(n.p,{children:["First, define the service interface in a ",(0,t.jsx)(n.code,{children:".srv"})," file (e.g., ",(0,t.jsx)(n.code,{children:"SetJointPosition.srv"}),"):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# Request\nstring joint_name\nfloat64 position\n---\n# Response\nbool success\nstring message\n"})}),"\n",(0,t.jsx)(n.p,{children:"Then implement the server:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from rclpy.node import Node\nfrom rclpy.action import ActionServer\nfrom your_interfaces.srv import SetJointPosition  # Custom service type\n\nclass JointControlService(Node):\n    def __init__(self):\n        super().__init__('joint_control_service')\n        self.srv = self.create_service(\n            SetJointPosition,\n            'set_joint_position',\n            self.set_joint_position_callback\n        )\n\n    def set_joint_position_callback(self, request, response):\n        # Implement joint control logic here\n        self.get_logger().info(f'Setting {request.joint_name} to {request.position}')\n\n        # Simulate joint movement\n        success = self.move_joint(request.joint_name, request.position)\n\n        response.success = success\n        response.message = f'Joint {request.joint_name} set to {request.position}'\n\n        return response\n\n    def move_joint(self, joint_name, position):\n        # Implementation of actual joint movement\n        # This would interface with real hardware or simulation\n        return True  # Simulated success\n"})}),"\n",(0,t.jsx)(n.p,{children:"And the client:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"import rclpy\nfrom rclpy.node import Node\nfrom your_interfaces.srv import SetJointPosition\n\nclass JointControlClient(Node):\n    def __init__(self):\n        super().__init__('joint_control_client')\n        self.cli = self.create_client(SetJointPosition, 'set_joint_position')\n        while not self.cli.wait_for_service(timeout_sec=1.0):\n            self.get_logger().info('Service not available, waiting again...')\n\n    def send_request(self, joint_name, position):\n        request = SetJointPosition.Request()\n        request.joint_name = joint_name\n        request.position = position\n        self.future = self.cli.call_async(request)\n        return self.future\n\ndef main(args=None):\n    rclpy.init(args=args)\n    joint_control_client = JointControlClient()\n\n    future = joint_control_client.send_request('left_knee_joint', 0.5)\n\n    rclpy.spin_until_future_complete(joint_control_client, future)\n\n    response = future.result()\n    joint_control_client.get_logger().info(f'Response: {response.success}, {response.message}')\n\n    joint_control_client.destroy_node()\n    rclpy.shutdown()\n"})}),"\n",(0,t.jsx)(n.h2,{id:"actions-goal-oriented-communication",children:"Actions: Goal-Oriented Communication"}),"\n",(0,t.jsx)(n.p,{children:"Actions are used for long-running tasks that require feedback, goal management, and cancellation. They're ideal for humanoid robot behaviors like walking, grasping, or navigation."}),"\n",(0,t.jsx)(n.h3,{id:"action-communication-pattern",children:"Action Communication Pattern"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mermaid",children:"graph LR\n    A[Action Client] --\x3e|Goal Request| C[Action Server]\n    C --\x3e|Feedback| A\n    C --\x3e|Result| A\n    A --\x3e|Cancel| C\n\n    style A fill:#FF5722\n    style C fill:#795548\n"})}),"\n",(0,t.jsx)(n.p,{children:"In this diagram:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Orange node: Action Client (sends goals, receives feedback/results, can cancel)"}),"\n",(0,t.jsx)(n.li,{children:"Brown node: Action Server (processes goals, sends feedback/results)"}),"\n"]}),"\n",(0,t.jsx)(n.h3,{id:"implementing-action-pattern",children:"Implementing Action Pattern"}),"\n",(0,t.jsxs)(n.p,{children:["Define the action interface in a ",(0,t.jsx)(n.code,{children:".action"})," file (e.g., ",(0,t.jsx)(n.code,{children:"Walk.action"}),"):"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{children:"# Goal\nfloat64[] target_position\nfloat64 speed\n---\n# Result\nbool success\nstring message\nfloat64[] final_position\n---\n# Feedback\nfloat64[] current_position\nfloat64[] remaining_distance\nstring status\n"})}),"\n",(0,t.jsx)(n.p,{children:"Implement the action server:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-python",children:"from rclpy.action import ActionServer, GoalResponse, CancelResponse\nfrom rclpy.callback_groups import ReentrantCallbackGroup\nfrom your_interfaces.action import Walk  # Custom action type\n\nclass WalkActionServer(Node):\n    def __init__(self):\n        super().__init__('walk_action_server')\n        self._action_server = ActionServer(\n            self,\n            Walk,\n            'walk_to_position',\n            execute_callback=self.execute_callback,\n            goal_callback=self.goal_callback,\n            cancel_callback=self.cancel_callback,\n            callback_group=ReentrantCallbackGroup())\n\n    def goal_callback(self, goal_request):\n        # Accept or reject the goal\n        self.get_logger().info('Received goal request')\n        return GoalResponse.ACCEPT\n\n    def cancel_callback(self, goal_handle):\n        # Accept or reject the cancel request\n        self.get_logger().info('Received cancel request')\n        return CancelResponse.ACCEPT\n\n    async def execute_callback(self, goal_handle):\n        self.get_logger().info('Executing goal...')\n\n        # Simulate walking process\n        feedback_msg = Walk.Feedback()\n        result = Walk.Result()\n\n        # In a real implementation, this would control the robot's walking\n        for i in range(10):\n            if goal_handle.is_cancel_requested:\n                goal_handle.canceled()\n                result.success = False\n                result.message = 'Goal canceled'\n                return result\n\n            # Simulate progress\n            feedback_msg.current_position = [i * 0.1, 0.0, 0.0]\n            feedback_msg.remaining_distance = [1.0 - (i * 0.1), 0.0, 0.0]\n            feedback_msg.status = f'Walking step {i+1}/10'\n\n            goal_handle.publish_feedback(feedback_msg)\n            self.get_logger().info(f'Feedback: {feedback_msg.status}')\n\n            # Sleep to simulate walking\n            await asyncio.sleep(0.5)\n\n        goal_handle.succeed()\n        result.success = True\n        result.message = 'Successfully walked to position'\n        result.final_position = [1.0, 0.0, 0.0]\n\n        self.get_logger().info('Goal succeeded')\n        return result\n"})}),"\n",(0,t.jsx)(n.h2,{id:"humanoid-robot-communication-architecture",children:"Humanoid Robot Communication Architecture"}),"\n",(0,t.jsx)(n.p,{children:"For humanoid robots, communication patterns are often combined in complex ways:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-mermaid",children:'graph TB\n    subgraph "Perception Layer"\n        A[IMU Sensor Node] --\x3e|sensor_data/imu| M[middleware]\n        B[Camera Node] --\x3e|sensor_data/image| M\n        C[Lidar Node] --\x3e|sensor_data/scan| M\n    end\n\n    subgraph "Processing Layer"\n        M --\x3e|processed_data| D[State Estimation Node]\n        D --\x3e|robot_state| E[Behavior Manager Node]\n    end\n\n    subgraph "Control Layer"\n        E --\x3e|joint_commands| F[Joint Controller Node]\n        F --\x3e|motor_commands| G[Motor Drivers]\n    end\n\n    subgraph "High-level Planning"\n        E -.->|service_request| H[Path Planner Service]\n        H -.->|service_response| E\n    end\n\n    style A fill:#8BC34A\n    style B fill:#8BC34A\n    style C fill:#8BC34A\n    style D fill:#2196F3\n    style E fill:#FF9800\n    style F fill:#FF5722\n    style G fill:#9C27B0\n    style H fill:#E91E63\n'})}),"\n",(0,t.jsx)(n.p,{children:"In this architecture:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Green: Sensor nodes (publishers)"}),"\n",(0,t.jsx)(n.li,{children:"Blue: State estimation (subscriber and publisher)"}),"\n",(0,t.jsx)(n.li,{children:"Orange: Behavior management (complex communication)"}),"\n",(0,t.jsx)(n.li,{children:"Red: Service-based planning"}),"\n",(0,t.jsx)(n.li,{children:"Purple: Motor drivers"}),"\n",(0,t.jsx)(n.li,{children:"Pink: Joint controllers"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"performance-considerations",children:"Performance Considerations"}),"\n",(0,t.jsxs)(n.admonition,{type:"info",children:[(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Hardware Note"}),": On Jetson Orin Nano, communication patterns have different performance characteristics:"]}),(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Topics: Up to 10kHz for critical control data"}),"\n",(0,t.jsxs)(n.li,{children:["Services: ",(0,t.jsx)(n.code,{children:"<10Hz"})," for configuration changes"]}),"\n",(0,t.jsx)(n.li,{children:"Actions: As needed for complex behaviors"}),"\n"]})]}),"\n",(0,t.jsx)(n.p,{children:"For real-time humanoid control, consider:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsx)(n.li,{children:"Use reliable QoS for critical control data"}),"\n"]}),"\n",(0,t.jsx)(n.h2,{id:"summary",children:"Summary"}),"\n",(0,t.jsx)(n.p,{children:"This chapter explored the three primary communication patterns in ROS 2: topics for asynchronous data flow, services for synchronous request/response, and actions for complex, long-running tasks. We demonstrated how these patterns work together in humanoid robot systems and provided practical examples for implementation. The next chapter will cover how to bridge high-level AI logic with these ROS 2 communication patterns."})]})}function u(e={}){const{wrapper:n}={...(0,o.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453(e,n,i){i.d(n,{R:()=>r,x:()=>l});var s=i(6540);const t={},o=s.createContext(t);function r(e){const n=s.useContext(o);return s.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function l(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(t):e.components||t:r(e.components),s.createElement(o.Provider,{value:n},e.children)}}}]);